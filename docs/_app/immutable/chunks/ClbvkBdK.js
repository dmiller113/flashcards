const v=(e,n,{onBlock:t,onError:o,onSuccess:d,onUpgrade:s}={})=>{const c=window.indexedDB.open(e,n);return t!==void 0&&(c.onblocked=t),s!==void 0&&(c.onupgradeneeded=s),a(c,{onReject:o,onResolve:d})},p=(e,n,{transaction:t,transactionDurability:o="relaxed",transactionMode:d="readonly"}={})=>{const s=t===void 0?e.transaction([n],d,{durability:o}):t,c=s.objectStore(n);return{_objectStore:c,_transaction:s,addObject:j(c),getObject:m(c),putObject:O(c)}},j=e=>async(n,t)=>{const o=e.add(n,t);return a(o)},m=e=>n=>{const t=e.get(n);return a(t)},O=e=>async(n,t)=>{const o=e.put(n,t);return a(o)},x=(e,n,t)=>{const o=e.createObjectStore(n,t);let d=[],s;const c=()=>{d.forEach(r=>r())};return s={build:()=>new Promise((r,b)=>{c(),o.transaction.oncomplete=()=>r(),o.transaction.onerror=l=>b(l)}),db:e,makeIndex:(r,b,l)=>(d=d.concat(()=>o.createIndex(r,b,l)),s),syncBuild:c},s},a=(e,{onReject:n,onResolve:t,rejectEventName:o="error",resolveEventName:d="success"}={})=>new Promise((s,c)=>{const i=()=>{e.removeEventListener(o,u);let r=e.result;t!==void 0&&(r=t(r)??r),s(r)},u=()=>{e.removeEventListener(d,i);let r=e.error;n!==void 0&&(r=n(r)??r),c(e.error)};e.addEventListener(d,i,{once:!0}),e.addEventListener(o,u,{once:!0})});export{p as a,v as g,x as m};
